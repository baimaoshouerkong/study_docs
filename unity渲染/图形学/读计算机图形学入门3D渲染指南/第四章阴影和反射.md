# 前情回顾
第三章对光线与物体表面相互作用的方程。这一章我们将对光线与场景交互方式的两个方面进行建模：物体投射阴影和物体反射到其他物体上。
# 阴影
所谓为的阴影就是光线没有照到的地方，而如何确定一点是不是阴影？其实很简单，只需要将光源和那个点连起来看是否会与其他的物体相交。
```
ClosestIntersection(O, D, t_min, t_max){
    closest_t = inf
    closest_sphere = NULL
    for sphere in scene.Spheres{
        t1, t2 = IntersectRaySphere(O, D, sphere)
        if t1 < closest_t && t_min < t1 && t1 < t_max {
            closest_t = t1
            closest_sphere = sphere
        }
        if t2 < closest_t && t_min < t2 && t2 < t_max {
            closest_t = t2
            closest_sphere = sphere
        }
    }
    return closest_sphere,closest_t
}
```
```
TraceRay(O, D, t_min, t_max){
    closest_sphere,closest_t = ClosestIntersection(O, D, t_min, t_max)
    if closest_sphere == null {
        return background_color
    }
    P = O + D * closest_t // 计算交点
    N = P - closest_sphere.center // 计算法线
    N = N / length(N) // 归一化法线
    i = ComputeLighting(P, N, -D , closest_sphere.specular)
    return i * closest_sphere.color
}
```
```
ComputeLighting(P, N , V ,s){
    i = 0.0
    for light in scene.Lights{
        if light.type == "ambient"{
            i += light.intensity
        }else{
            if light.type == "point"{
                L = light.position - P
            }else {
                L = light.direction
            }
            // 漫反射
            n_dot_l = dot(N, L)
            if n_dot_l > 0 {
                i += light.intensity * n_dot_l / (length(N) * length(L))
            }
            // 镜面反射
            if s != -1{
                R = 2 * N * (dot(N, L)) - L
                r_dot_v = dot(R, V)
                if r_dot_v > 0 {
                    i += light.intensity * Math.pow(r_dot_v / (length(R) * length(V)), s)
                }
            } 
        }
    }
    return i
}
```
